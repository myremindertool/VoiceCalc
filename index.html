
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>üé§ Voice Calculator (Advanced)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body{font-family:Arial,system-ui;background:#fce4ec;margin:0;text-align:center;padding:20px}
    h1{color:#d81b60;margin:8px 0}
    .note{color:#7a2f4b;font-size:13px;margin-top:4px}
    .panel{
      display:inline-block;background:#fff; border-radius:14px; padding:16px 16px 12px;
      box-shadow:0 8px 30px rgba(0,0,0,.12)
    }
    .display{
      background:#fff5f8;border-radius:10px;padding:10px 12px;text-align:right;
      border:1px solid rgba(0,0,0,.06)
    }
    .expr{font-size:14px;color:#b04873;word-break:break-all;min-height:18px}
    .ans{font-size:28px;color:#4a0f26;word-break:break-all;min-height:32px}
    .status{font-size:11px;color:#7a2f4b;text-align:left;margin-top:4px}
    .grid{
      display:grid; grid-template-columns:repeat(4,70px); gap:10px; margin-top:14px; justify-content:center;
    }
    .btn{
      padding:14px; font-size:18px; border:0; border-radius:10px; background:#fff;
      box-shadow:0 2px 5px rgba(0,0,0,.15); cursor:pointer; transition:.12s;
      user-select:none
    }
    .btn:active{transform:translateY(1px)}
    .btn.operator{background:#ffb74d}
    .btn.func{background:#ffecb3}
    .btn.util{background:#ffe1e7}
    .btn.equals{background:#81d4fa}
    .btn.danger{background:#ff8a80;color:#611b1b}
    .btn.active{outline:3px solid #81d4fa}
    .bar{
      display:flex; gap:8px; align-items:center; justify-content:center; margin-top:14px; flex-wrap:wrap
    }
    .mic{
      display:flex; align-items:center; gap:8px; background:#ffe1e7; border:1px solid rgba(0,0,0,.08);
      border-radius:999px; padding:6px 10px;
    }
    .mic .dot{width:10px;height:10px;border-radius:999px;background:#9e9e9e}
    .mic.active .dot{background:#43a047; box-shadow:0 0 0 6px rgba(67,160,71,.12)}
    #speak-btn{background:#2196f3;color:#fff}
    .chip{font-size:12px;color:#7a2f4b;background:#fff;border:1px solid rgba(0,0,0,.06);padding:4px 8px;border-radius:999px}
    .footer{font-size:12px;color:#7a2f4b;margin-top:10px}
  </style>
</head>
<body>

<h1>üé§ Voice Calculator</h1>
<div class="note">Angles: <b>degrees</b>. Say things like ‚Äúsquare root of forty five equals‚Äù, ‚Äúsine thirty‚Äù, ‚Äútwo power three‚Äù.</div>

<div class="panel" role="application" aria-label="Advanced voice calculator">
  <div class="display" aria-live="polite">
    <div class="expr" id="expression"></div>
    <div class="ans" id="answer">0</div>
    <div class="status" id="status">Ready</div>
  </div>

  <div class="grid" id="pad">
    <!-- Row 1 -->
    <button class="btn util" id="btn-clr" data-action="C">CLR</button>
    <button class="btn util" id="btn-bk" data-action="BK">‚å´</button>
    <button class="btn func" id="btn-lp" data-op="(">(</button>
    <button class="btn func" id="btn-rp" data-op=")">)</button>

    <!-- Row 2 -->
    <button class="btn func" id="btn-sqrt" data-fn="sqrt">‚àö</button>
    <button class="btn func" id="btn-square" data-fn="square">x¬≤</button>
    <button class="btn func" id="btn-cube" data-fn="cube">x¬≥</button>
    <button class="btn func" id="btn-inv" data-fn="inv">1/x</button>

    <!-- Row 3 -->
    <button class="btn func" id="btn-abs" data-fn="abs">|x|</button>
    <button class="btn func" id="btn-fact" data-fn="fact">x!</button>
    <button class="btn func" id="btn-sin" data-fn="sin">sin</button>
    <button class="btn func" id="btn-cos" data-fn="cos">cos</button>

    <!-- Row 4 -->
    <button class="btn func" id="btn-tan" data-fn="tan">tan</button>
    <button class="btn func" id="btn-log" data-fn="log">log</button>
    <button class="btn func" id="btn-ln" data-fn="ln">ln</button>
    <button class="btn operator" id="btn-div" data-op="/">√∑</button>

    <!-- Row 5 -->
    <button class="btn" data-num="7" id="btn-7">7</button>
    <button class="btn" data-num="8" id="btn-8">8</button>
    <button class="btn" data-num="9" id="btn-9">9</button>
    <button class="btn operator" id="btn-mul" data-op="*">√ó</button>

    <!-- Row 6 -->
    <button class="btn" data-num="4" id="btn-4">4</button>
    <button class="btn" data-num="5" id="btn-5">5</button>
    <button class="btn" data-num="6" id="btn-6">6</button>
    <button class="btn operator" id="btn-min" data-op="-">‚àí</button>

    <!-- Row 7 -->
    <button class="btn" data-num="1" id="btn-1">1</button>
    <button class="btn" data-num="2" id="btn-2">2</button>
    <button class="btn" data-num="3" id="btn-3">3</button>
    <button class="btn operator" id="btn-plus" data-op="+">+</button>

    <!-- Row 8 -->
    <button class="btn func" id="btn-pi" data-const="PI">œÄ</button>
    <button class="btn" data-num="0" id="btn-0">0</button>
    <button class="btn" data-num="." id="btn-dot">.</button>
    <button class="btn operator" id="btn-pow" data-op="^">^</button>

    <!-- Row 9 -->
    <button class="btn func" id="btn-e" data-const="E">e</button>
    <button class="btn func" id="btn-neg" data-fn="neg">¬±</button>
    <button class="btn func" id="btn-pct" data-fn="percent">%</button>
    <button class="btn equals" id="btn-eq" data-action="EQ">=</button>
  </div>

  <div class="bar">
    <div class="mic" id="micBox" title="Voice input">
      <div class="dot"></div>
      <button class="btn" id="speak-btn">üéôÔ∏è Speak</button>
      <span id="liveText" class="chip">Tap and say: ‚Äúsquare root of forty five equals‚Äù</span>
    </div>
    <span class="chip">Digits & ops work by click, keyboard, and voice</span>
  </div>

  <div class="footer">
    Voice words: plus, minus, times/multiply, divided by, power, percent, open/close parenthesis, point/dot, root/square root, square, cube,
    sine/cosine/tangent, log, natural log, factorial, absolute, pi, e, equals/solve.
  </div>
</div>

<script>
(() => {
  // ---------------- Display & state ----------------
  const exprEl = document.getElementById("expression");
  const ansEl  = document.getElementById("answer");
  const statusEl = document.getElementById("status");
  const pad = document.getElementById("pad");

  let expression = "";
  let justEvaluated = false;
  const TRIG_IN_DEGREES = true;

  function setStatus(s){ statusEl.textContent = s; }
  function setExpr(s){ exprEl.textContent = s; }
  function setAns(s){ ansEl.textContent = s; }

  // ---------------- Math engine (safe) ----------------
  const precedence = { "+":2, "-":2, "*":3, "/":3, "^":4, "%":5, "!":5 };
  const rightAssoc = { "^":true };
  const funcs = new Set(["sqrt","square","cube","inv","fact","sin","cos","tan","log","ln","abs","neg","percent"]);
  const constants = { "PI":Math.PI, "E":Math.E };
  const toRad = x => x * Math.PI / 180;

  function factorial(n){
    if (!Number.isFinite(n) || n<0 || Math.floor(n) !== n) throw new Error("Factorial on non-negative integers only");
    let r=1; for (let i=2;i<=n;i++) r*=i; return r;
  }
  function applyFunc(fn, v){
    switch(fn){
      case "sqrt": return Math.sqrt(v);
      case "square": return v*v;
      case "cube": return v*v*v;
      case "inv": return 1/v;
      case "fact": return factorial(v);
      case "sin": return Math.sin(TRIG_IN_DEGREES ? toRad(v) : v);
      case "cos": return Math.cos(TRIG_IN_DEGREES ? toRad(v) : v);
      case "tan": return Math.tan(TRIG_IN_DEGREES ? toRad(v) : v);
      case "log": return Math.log10(v);
      case "ln":  return Math.log(v);
      case "abs": return Math.abs(v);
      case "neg": return -v;
      case "percent": return v/100; // postfix % acts like divide by 100
      default: throw new Error("Unknown function");
    }
  }

  function balanceParens(s){
    let open=0; for(const ch of s){ if(ch==='(') open++; else if(ch===')') open=Math.max(0, open-1); }
    return open>0 ? s + ')'.repeat(open) : s;
  }

  function tokenize(str){
    const s = str.replace(/\s+/g,"");
    const tokens=[];
    const re=/([0-9]*\.?[0-9]+(?:e[+\-]?[0-9]+)?)|([A-Za-z]+)|([\+\-\*\/\^\%\!\(\)])/y;
    let i=0;
    while(i<s.length){
      re.lastIndex=i;
      const m=re.exec(s);
      if(!m) throw new Error("Invalid token near: "+s.slice(i,i+8));
      if (m[1]) tokens.push({type:"num", value:m[1]});
      else if (m[2]){
        const name=m[2];
        if (funcs.has(name)) tokens.push({type:"fn", value:name});
        else if (name in constants) tokens.push({type:"const", value:name});
        else throw new Error("Unknown symbol: "+name);
      } else if (m[3]) tokens.push({type:"op", value:m[3]});
      i=re.lastIndex;
    }
    return tokens;
  }

  function toRPN(tokens){
    const out=[], stack=[];
    let prev = null;
    for (const t of tokens){
      if (t.type==="num"||t.type==="const"){ out.push(t); }
      else if (t.type==="fn"){ stack.push(t); }
      else if (t.type==="op"){
        if (t.value==="("){ stack.push(t); }
        else if (t.value===")"){
          while(stack.length && stack[stack.length-1].value!=="(") out.push(stack.pop());
          if(!stack.length) throw new Error("Mismatched )");
          stack.pop();
          if(stack.length && stack[stack.length-1].type==="fn") out.push(stack.pop());
        } else {
          // unary minus -> 'neg'
          if (t.value==="-" && (prev===null || (prev.type==="op" && prev.value!=="") && prev.value!=="(")){
            stack.push({type:"fn", value:"neg"});
          } else {
            while(stack.length){
              const top=stack[stack.length-1];
              if (top.type==="op" && top.value!=="("){
                const p1=precedence[t.value]||0, p2=precedence[top.value]||0;
                if ((rightAssoc[t.value] && p1<p2) || (!rightAssoc[t.value] && p1<=p2)) out.push(stack.pop());
                else break;
              } else if (top.type==="fn"){ out.push(stack.pop()); }
              else break;
            }
            stack.push(t);
          }
        }
      }
      prev = t;
    }
    while(stack.length){
      const x=stack.pop();
      if (x.value==="("||x.value===")") throw new Error("Mismatched parentheses");
      out.push(x);
    }
    return out;
  }

  function evalRPN(rpn){
    const st=[];
    for(const t of rpn){
      if (t.type==="num") st.push(parseFloat(t.value));
      else if (t.type==="const") st.push(constants[t.value]);
      else if (t.type==="fn"){
        if (st.length<1) throw new Error("Insufficient values");
        const v = st.pop();
        const res=applyFunc(t.value, v);
        if (!Number.isFinite(res)) throw new Error("Math domain");
        st.push(res);
      } else if (t.type==="op"){
        if (t.value==="!" || t.value==="%"){
          if (st.length<1) throw new Error("Insufficient values");
          const a = st.pop();
          st.push(t.value==="!" ? applyFunc("fact", a) : applyFunc("percent", a));
        } else {
          if (st.length<2) throw new Error("Insufficient values");
          const b=st.pop(), a=st.pop();
          let r;
          switch(t.value){
            case "+": r=a+b; break;
            case "-": r=a-b; break;
            case "*": r=a*b; break;
            case "/": r=a/b; break;
            case "^": r=Math.pow(a,b); break;
            default: throw new Error("Unknown op");
          }
          if (!Number.isFinite(r)) throw new Error("Math domain");
          st.push(r);
        }
      }
    }
    if (st.length!==1) throw new Error("Invalid expression");
    return st[0];
  }

  function evaluateExpression(expr){
    const tokens = tokenize(expr);
    const rpn = toRPN(tokens);
    return evalRPN(rpn);
  }

  function formatNumber(n){
    if (!Number.isFinite(n)) return "Error";
    const abs=Math.abs(n);
    if (abs!==0 && (abs<1e-6 || abs>=1e10)) return n.toExponential(10).replace(/\.?0+e/,'e');
    let s=n.toFixed(12); s=s.replace(/\.?0+$/,''); return s;
  }

  // ---------------- Input helpers ----------------
  function preview(){
    try{
      const v = evaluateExpression(balanceParens(expression));
      setAns(formatNumber(v));
      setStatus("OK");
    }catch{
      setAns(expression ? "‚Ä¶" : "0");
      setStatus(expression ? "Editing" : "Ready");
    }
    setExpr(expression);
  }

  function pushText(t){
    if (justEvaluated && /^[0-9.(]|PI|E/.test(t)) expression="";
    expression += t;
    justEvaluated=false;
    preview();
  }

  function doEquals(){
    try{
      const v = evaluateExpression(balanceParens(expression));
      const s = formatNumber(v);
      setAns(s);
      expression = s;
      setExpr(expression);
      setStatus("Solved");
      justEvaluated=true;
    }catch{
      setAns("Error"); setStatus("Error");
    }
  }

  function doBackspace(){
    if (!expression) return;
    expression = expression.slice(0,-1);
    preview();
  }

  function clearAll(){ expression=""; preview(); }

  function wrapLastWith(fn){
    const m=/(?:PI|E|\)|\d+(?:\.\d+)?(?:e[+\-]?\d+)?|\.\d+)$/.exec(expression);
    if (m){
      const i=m.index, atom=m[0];
      expression = expression.slice(0,i) + `${fn}(${atom})`;
    }else{
      expression += `${fn}(`;
    }
    preview();
  }

  function postfix(post){ // like ! or %
    if (/\d|\)|I|E$/.test(expression)){
      expression += post; preview();
    }
  }

  // ---------------- Button clicks ----------------
  pad.addEventListener('click', (e)=>{
    const b = e.target.closest('button'); if (!b) return;
    b.classList.add('active'); setTimeout(()=>b.classList.remove('active'), 200);

    if (b.dataset.num !== undefined) pushText(b.dataset.num);
    else if (b.dataset.op) pushText(b.dataset.op);
    else if (b.dataset.const) pushText(b.dataset.const);
    else if (b.dataset.fn){
      const f=b.dataset.fn;
      if (f==="fact") postfix("!");
      else if (f==="percent") postfix("%");
      else if (["square","cube","sqrt","inv","abs","sin","cos","tan","log","ln"].includes(f)) wrapLastWith(f);
      else if (f==="neg"){ pushText("neg("); pushText(")"); }
    }
    else if (b.dataset.action){
      if (b.dataset.action==="C") clearAll();
      else if (b.dataset.action==="BK") doBackspace();
      else if (b.dataset.action==="EQ") doEquals();
    }
  });

  // ---------------- Keyboard (optional) ----------------
  document.addEventListener('keydown', (e)=>{
    const k=e.key;
    if (/^[0-9.]$/.test(k)) { pushText(k); return; }
    if ("+-*/^()".includes(k)) { pushText(k); return; }
    if (k==="Enter" || k==="="){ e.preventDefault(); doEquals(); }
    if (k==="Backspace"){ e.preventDefault(); doBackspace(); }
    if (k==="%"){ postfix("%"); }
  });

  // ---------------- Voice: Android-friendly ----------------
  const micBtn = document.getElementById('speak-btn');
  const micBox = document.getElementById('micBox');
  const liveText = document.getElementById('liveText');
  let recognition, recognizing=false;

  const ARABIC_INDIC = {"Ÿ†":"0","Ÿ°":"1","Ÿ¢":"2","Ÿ£":"3","Ÿ§":"4","Ÿ•":"5","Ÿ¶":"6","Ÿß":"7","Ÿ®":"8","Ÿ©":"9"};
  function toLatinDigits(s){ return s.replace(/[Ÿ†-Ÿ©]/g, ch => ARABIC_INDIC[ch] ?? ch); }

  const smallNums = {"zero":0,"oh":0,"one":1,"two":2,"to":2,"too":2,"three":3,"four":4,"for":4,"five":5,"six":6,"seven":7,"eight":8,"ate":8,"nine":9,"ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,"seventeen":17,"eighteen":18,"nineteen":19};
  const tensNums = {"twenty":20,"thirty":30,"forty":40,"fourty":40,"fifty":50,"sixty":60,"seventy":70,"eighty":80,"ninety":90};
  const scales   = {"hundred":100, "thousand":1000};

  function wordsChunkToNumber(words){
    let total=0,current=0,i=0,had=false,decimal=false,dec="";
    while(i<words.length){
      const w=words[i];
      if (w==="and"){ i++; continue; }
      if (w==="point"||w==="dot"){ decimal=true; i++; continue; }
      if (decimal){
        if (w in smallNums){ dec += String(smallNums[w]); had=true; i++; continue; }
        if (/^\d+$/.test(w)){ dec += w; had=true; i++; continue; }
        break;
      }
      if (w in smallNums){ current += smallNums[w]; had=true; i++; continue; }
      if (w in tensNums){ current += tensNums[w]; had=true; i++; continue; }
      if (w in scales){ current = (current||1)*scales[w]; had=true; i++; continue; }
      if (/^\d+$/.test(w)){ current = current*10 + parseInt(w,10); had=true; i++; continue; }
      break;
    }
    total += current;
    if (!had) return null;
    return { value: decimal ? (String(total)+"."+(dec||"0")) : String(total), used:i };
  }

  function collapseNumberWords(text){
    const tokens=text.trim().split(/\s+/); const out=[];
    for(let i=0;i<tokens.length;){
      const slice=tokens.slice(i); const parsed=wordsChunkToNumber(slice);
      if (parsed){ out.push(parsed.value); i+=parsed.used; } else { out.push(tokens[i]); i++; }
    }
    return out.join(" ");
  }

  const voiceMap = [
    ["multiplied by","*"],["divided by","/"],["to the power","^"],["raised to","^"],
    ["open parenthesis","("],["open bracket","("],["left parenthesis","("],
    ["close parenthesis",")"],["close bracket",")"],["right parenthesis",")"],
    ["square root of","sqrt("],["root of","sqrt("],["square root","sqrt("],["root","sqrt("],
    ["natural log","ln("],
    ["plus","+"],["minus","-"],["times","*"],["multiply","*"],["into","*"],
    ["divide","/"],["over","/"],["power","^"],["percent","%"],
    ["point","."],["dot","."],
    ["square","square("],["cube","cube("],
    ["inverse","inv("],["one by","inv("],
    ["factorial","!"],
    ["sine","sin("],["sign","sin("],["cosine","cos("],["tangent","tan("],["tan","tan("],
    ["log","log("],["ln","ln("],["absolute","abs("],["modulus","abs("],
    ["pi","PI"],["pie","PI"],["e","E"],
    ["plus or minus","neg("],["negative","neg("],
    ["all clear","__CLR__"],["clear","__CLR__"],
    ["backspace","__BK__"],["delete","__BK__"],
    ["equals","__EQ__"],["equal","__EQ__"],["solve","__EQ__"],["result","__EQ__"]
  ];

  function applyVoiceMap(text){
    let t=" " + (text||"").toLowerCase().trim() + " ";
    t = toLatinDigits(t);
    t = collapseNumberWords(t);
    const ordered=[...voiceMap].sort((a,b)=>b[0].length-a[0].length);
    for(const [k,v] of ordered){
      const re=new RegExp("\\b"+k.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")+"\\b","g");
      t = t.replace(re, " "+v+" ");
    }
    return t.trim().replace(/\s+/g,"");
  }

  const highlightMap = {
    "0":"btn-0","1":"btn-1","2":"btn-2","3":"btn-3","4":"btn-4","5":"btn-5","6":"btn-6","7":"btn-7","8":"btn-8","9":"btn-9",".":"btn-dot",
    "+":"btn-plus","-":"btn-min","*":"btn-mul","/":"btn-div","^":"btn-pow","(":"btn-lp",")":"btn-rp",
    "sqrt":"btn-sqrt","square":"btn-square","cube":"btn-cube","inv":"btn-inv","abs":"btn-abs","fact":"btn-fact","sin":"btn-sin","cos":"btn-cos","tan":"btn-tan","log":"btn-log","ln":"btn-ln",
    "PI":"btn-pi","E":"btn-e","%":"btn-pct","neg":"btn-neg"
  };
  function highlightTokens(norm){
    // break into readable tokens for button highlight
    const parts = norm.match(/PI|E|sqrt|square|cube|inv|abs|sin|cos|tan|log|ln|neg|[0-9]+|[+\-*/^()%!.]/g) || [];
    const seen = new Set();
    for(const p of parts){
      let key=p;
      if (["sqrt","square","cube","inv","abs","sin","cos","tan","log","ln","neg"].includes(p)) { /* as is */ }
      else if (/^\d/.test(p)) key = p[0]; // highlight first digit only to avoid many blinks
      else if (p==="!") key = "fact";
      const id = highlightMap[key];
      if (id && !seen.has(id)){
        const el=document.getElementById(id);
        if (el){ el.classList.add("active"); setTimeout(()=>el.classList.remove("active"), 250); }
        seen.add(id);
      }
    }
  }

  function appendVoice(norm){
    if (norm.includes("__CLR__")) { clearAll(); norm = norm.replaceAll("__CLR__",""); }
    if (norm.includes("__BK__"))  { doBackspace(); norm = norm.replaceAll("__BK__",""); }
    if (!norm) return;

    const endsEq = norm.endsWith("__EQ__");
    norm = norm.replaceAll("__EQ__","");

    expression += norm;
    highlightTokens(norm);
    preview();
    if (endsEq) doEquals();
  }

  function initSpeech(){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR){
      liveText.textContent = "Voice not supported in this browser";
      micBtn.disabled=true; return;
    }
    recognition = new SR();
    recognition.lang = "en-IN"; // try 'en-IN' for better Android results; change if you prefer
    recognition.interimResults = false; // final only (avoid noisy interims)
    recognition.continuous = true;

    recognition.onresult = (ev)=>{
      let spoken="";
      for(let i=ev.resultIndex;i<ev.results.length;i++){
        const res=ev.results[i];
        if (res.isFinal) spoken += (res[0].transcript + " ");
      }
      spoken=spoken.trim();
      if (!spoken) return;
      liveText.textContent = "Heard: " + spoken;
      const norm = applyVoiceMap(spoken);
      appendVoice(norm);
    };
    recognition.onerror = (e)=>{ setStatus("Mic error"); console.warn(e.error); };
    recognition.onend = ()=>{ recognizing=false; micBox.classList.remove("active"); setStatus("Mic off"); };
  }

  micBtn.addEventListener("click", ()=>{
    if (!recognition) initSpeech();
    if (!recogn
